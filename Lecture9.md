## 9.9

1️⃣ 首先，让我们按顺序构建二叉排序树（BST）：

我们从空树开始，依次插入每个月份。由于是按字母顺序比较，我们可以一步步插入:
- 首先插入Jan作为根节点
- 然后Feb比Jan大，放右子树
- Mar比Jan大，比Feb大，放Feb右子树
- 以此类推...

让我画出最终的二叉排序树结构:

```
            Jan
              \
              Feb
                \
                Mar
                  \
                  Apr
                    \
                    May
                      \
                      June
                        \
                        July
                          \
                          Aug
                            \
                            Sep
                              \
                              Oct
                                \
                                Nov
                                  \
                                  Dec
```

计算平均查找长度：
第1层(Jan): 需1次比较
第2层(Feb): 需2次比较
第3层(Mar): 需3次比较
...
第12层(Dec): 需12次比较

ASL = (1+2+3+4+5+6+7+8+9+10+11+12)/12 = 78/12 = 6.5 次比较

2️⃣ 对于有序表进行折半查找：

首先将表排序（已经按字母顺序排好）：
(Apr, Aug, Dec, Feb, Jan, July, June, Mar, May, Nov, Oct, Sep)

在折半查找中：
- 第1层(可以1次比较找到)：中间元素June
- 第2层(需2次比较)：Feb, Oct
- 第3层(需3次比较)：Apr, Mar, July, Nov
- 第4层(需4次比较)：Aug, Jan, May, Sep, Dec

平均查找长度：
ASL = (1×1 + 2×2 + 3×4 + 4×5)/12 = (1 + 4 + 12 + 20)/12 = 37/12 ≈ 3.08 次比较

3️⃣ 构造平衡二叉排序树：

为了构造平衡的BST，我们需要选择中位数作为根节点，然后递归地构造左右子树。最终的树结构如下：

```
           June
      /          \
    Feb           Oct
   /   \        /    \
 Apr    Jan    Mar    Nov
 /        \      \      \
Aug        July    May    Sep
/                          \
Dec                        
```

计算平均查找长度：
第1层(June): 1次比较 × 1个节点
第2层(Feb,Oct): 2次比较 × 2个节点
第3层(Apr,Jan,Mar,Nov): 3次比较 × 4个节点
第4层(Aug,July,May,Sep): 4次比较 × 4个节点
第5层(Dec): 5次比较 × 1个节点

ASL = (1×1 + 2×2 + 3×4 + 4×4 + 5×1)/12 
    = (1 + 4 + 12 + 16 + 5)/12 
    = 38/12 
    ≈ 3.17 次比较

比较三种方法的平均查找长度：
1. 直接构造BST：6.5次比较
2. 折半查找：3.08次比较
3. 平衡BST：3.17次比较

可以看到，折半查找和平衡BST的效率相近，都明显优于直接构造的BST。这说明在构造查找结构时，保持平衡性对提高查找效率非常重要。

## 9.14


1. 插入20：
```
[20]
```
这是最简单的情况，直接作为根节点。

2. 插入30：
```
[20,30]
```
30比20大，直接插入到同一节点中。

3. 插入50：
```
   [30]
  /    \
[20]   [50]
```
节点已满，需要分裂。选择中间值30上升，20和50分别作为左右子节点。

4. 插入52：
```
    [30]
   /    \
[20]   [50,52]
```
52比30大，进入右子树，可以直接插入到50所在的节点中。

5. 插入60：
```
     [30,50]
    /   |   \
[20]  [52]  [60]
```
右节点[50,52]已满，需要分裂。52保持在原位，50上升与30合并，60成为新的右子节点。

6. 插入68：
```
     [30,50]
    /   |   \
[20]  [52]  [60,68]
```
68比50大，进入最右子树，可以直接插入到60所在的节点中。

7. 插入70：
```
        [50]
      /      \
   [30]     [60,68]
  /    \    /   |   \
[20]  [52] []  []  [70]
```
最右节点[60,68,70]超出限制，需要分裂。68上升，但由于父节点[30,50]已满，因此需要再次分裂。

现在让我们执行删除操作：

8. 删除50：
```
        [52]
      /      \
   [30]     [60,68]
  /    \    /   |   \
[20]  []   []  []  [70]
```
50是内部节点，需要用其直接后继52替换，然后删除52。

9. 删除68：
```
        [52]
      /      \
   [30]      [60]
  /    \     /   \
[20]  []   []    [70]
```
68可以直接从叶节点中删除，由于删除后节点中关键码数量仍然满足要求，不需要额外的平衡操作。

这个过程展示了2-3树的几个重要特性：
1. 所有的增长都是向上的，这保证了树的平衡性
2. 所有的叶子节点始终保持在同一层
3. 节点分裂和合并操作确保了树的查找效率始终保持在一个理想的范围内

通过这种结构，2-3树可以在保持高度平衡的同时支持高效的插入和删除操作，这也是它作为B树家族重要成员的原因之一。

## 9.19

给定的哈希函数和处理冲突的方法：
- 主哈希函数：H(k) = (3k) MOD 11
- 处理冲突的增量函数：di = i × ((7k) MOD 10 + 1)，其中i是尝试次数

让我们逐个插入关键字：

1. k = 22
   - H(22) = (3×22) MOD 11 = 66 MOD 11 = 0
   - 位置0空闲，直接放入
   位置0：[22]

2. k = 41
   - H(41) = (3×41) MOD 11 = 123 MOD 11 = 2
   - 位置2空闲，直接放入
   位置0：[22]，位置2：[41]

3. k = 53
   - H(53) = (3×53) MOD 11 = 159 MOD 11 = 5
   - 位置5空闲，直接放入
   位置0：[22]，位置2：[41]，位置5：[53]

4. k = 46
   - H(46) = (3×46) MOD 11 = 138 MOD 11 = 6
   - 位置6空闲，直接放入
   位置0：[22]，位置2：[41]，位置5：[53]，位置6：[46]

5. k = 30
   - H(30) = (3×30) MOD 11 = 90 MOD 11 = 2
   - 位置2已占用，需要处理冲突
   - d1 = 1×((7×30) MOD 10 + 1) = 1×(210 MOD 10 + 1) = 1×1 = 1
   - 尝试位置：(2+1) MOD 11 = 3
   - 位置3空闲，放入
   位置0：[22]，位置2：[41]，位置3：[30]，位置5：[53]，位置6：[46]

6. k = 13
   - H(13) = (3×13) MOD 11 = 39 MOD 11 = 6
   - 位置6已占用，需要处理冲突
   - d1 = 1×((7×13) MOD 10 + 1) = 1×(91 MOD 10 + 1) = 1×2 = 2
   - 尝试位置：(6+2) MOD 11 = 8
   - 位置8空闲，放入
   位置0：[22]，位置2：[41]，位置3：[30]，位置5：[53]，位置6：[46]，位置8：[13]

7. k = 01
   - H(01) = (3×1) MOD 11 = 3 MOD 11 = 3
   - 位置3已占用，需要处理冲突
   - d1 = 1×((7×1) MOD 10 + 1) = 1×(7 MOD 10 + 1) = 1×8 = 8
   - 尝试位置：(3+8) MOD 11 = 0
   - 位置0已占用，需要继续处理冲突
   - d2 = 2×8 = 16
   - 尝试位置：(3+16) MOD 11 = 8
   - 位置8已占用，需要继续处理冲突
   - d3 = 3×8 = 24
   - 尝试位置：(3+24) MOD 11 = 5
   - 位置5已占用，需要继续处理冲突
   - d4 = 4×8 = 32
   - 尝试位置：(3+32) MOD 11 = 2
   - 位置2已占用，需要继续处理冲突
   - d5 = 5×8 = 40
   - 尝试位置：(3+40) MOD 11 = 10
   - 位置10空闲，放入
   位置0：[22]，位置2：[41]，位置3：[30]，位置5：[53]，位置6：[46]，位置8：[13]，位置10：[01]

8. k = 67
   - H(67) = (3×67) MOD 11 = 201 MOD 11 = 3
   - 位置3已占用，需要处理冲突
   - d1 = 1×((7×67) MOD 10 + 1) = 1×(469 MOD 10 + 1) = 1×10 = 10
   - 尝试位置：(3+10) MOD 11 = 2
   - 位置2已占用，需要继续处理冲突
   - d2 = 2×10 = 20
   - 尝试位置：(3+20) MOD 11 = 1
   - 位置1空闲，放入
   最终哈希表：位置0：[22]，位置1：[67]，位置2：[41]，位置3：[30]，位置5：[53]，位置6：[46]，位置8：[13]，位置10：[01]

现在计算平均查找长度：
- 22需要1次比较
- 41需要1次比较
- 53需要1次比较
- 46需要1次比较
- 30需要2次比较
- 13需要2次比较
- 01需要6次比较
- 67需要3次比较

平均查找长度 = (1+1+1+1+2+2+6+3)/8 = 17/8 = 2.125次比较

这个结果显示，虽然大多数关键字可以在1-2次比较内找到，但由于01的插入需要多次处理冲突，显著增加了平均查找长度。这提醒我们在选择哈希函数和处理冲突方法时，需要考虑可能出现的最坏情况对整体性能的影响。

## 9.20

装载因子(α) = 记录个数/表长
- 我们有12个关键字
- 要求装载因子α ≥ 0.75
- 因此，表长m应满足：12/m ≥ 0.75
- 解得：m ≤ 16

为了使装载因子尽可能接近0.75，我们可以选择表长m = 15，此时装载因子α = 12/15 = 0.8。

让我们设计一个简单但有效的哈希函数。由于关键字都是英文字符串，我们可以：
1. 取每个字符的ASCII码之和
2. 将和值除以表长取余

哈希函数：H(key) = (ASCII码和) MOD 15

让我们逐个计算并插入：

1. ZHAO：
   - ASCII和 = 90+72+65+79 = 306
   - H(ZHAO) = 306 MOD 15 = 6

2. QIAN：
   - ASCII和 = 81+73+65+78 = 297
   - H(QIAN) = 297 MOD 15 = 12

3. SUN：
   - ASCII和 = 83+85+78 = 246
   - H(SUN) = 246 MOD 15 = 6
   - 发生冲突，使用线性探测：放入位置7

4. LI：
   - ASCII和 = 76+73 = 149
   - H(LI) = 149 MOD 15 = 14

5. ZHOU：
   - ASCII和 = 90+72+79+85 = 326
   - H(ZHOU) = 326 MOD 15 = 11

6. WU：
   - ASCII和 = 87+85 = 172
   - H(WU) = 172 MOD 15 = 7
   - 发生冲突，使用线性探测：放入位置8

7. ZHANG：
   - ASCII和 = 90+72+65+78+71 = 376
   - H(ZHANG) = 376 MOD 15 = 1

8. WANG：
   - ASCII和 = 87+65+78+71 = 301
   - H(WANG) = 301 MOD 15 = 1
   - 发生冲突，使用线性探测：放入位置2

9. CHANG：
   - ASCII和 = 67+72+65+78+71 = 353
   - H(CHANG) = 353 MOD 15 = 8
   - 发生冲突，使用线性探测：放入位置9

10. CHAO：
    - ASCII和 = 67+72+65+79 = 283
    - H(CHAO) = 283 MOD 15 = 13

11. YANG：
    - ASCII和 = 89+65+78+71 = 303
    - H(YANG) = 303 MOD 15 = 3

12. JIN：
    - ASCII和 = 74+73+78 = 225
    - H(JIN) = 225 MOD 15 = 0

最终的哈希表（位置：[关键字，查找次数]）：
```
0: [JIN, 1]
1: [ZHANG, 1]
2: [WANG, 2]
3: [YANG, 1]
4: [-]
5: [-]
6: [ZHAO, 1]
7: [SUN, 2]
8: [WU, 2]
9: [CHANG, 3]
10: [-]
11: [ZHOU, 1]
12: [QIAN, 1]
13: [CHAO, 1]
14: [LI, 1]
```

计算平均查找长度：
- 1次比较：JIN, ZHANG, YANG, ZHAO, ZHOU, QIAN, CHAO, LI (8个)
- 2次比较：WANG, SUN, WU (3个)
- 3次比较：CHANG (1个)

平均查找长度 = (8×1 + 3×2 + 1×3)/12 = (8 + 6 + 3)/12 = 17/12 ≈ 1.42次

这个哈希表设计的优点是：
1. 满足装载因子要求（α = 0.8 > 0.75）
2. 平均查找长度较小（约1.42次）
3. 没有出现很长的探测序列（最多3次）
4. 分布相对均匀，大部分关键字只需1次比较就能找到

如果实际应用中发现性能不够理想，我们还可以：
1. 改用二次探测或双重散列来处理冲突
2. 调整表长为质数以减少冲突
3. 使用更复杂的哈希函数来改善关键字的分布

## 9.21

根据给定的哈希函数 H(x) = i/2，其中i是第一个字母在字母表中的序号（A=1, B=2, ...）：

Jan: H("J") = 10/2 = 5
Feb: H("F") = 6/2 = 3
Mar: H("M") = 13/2 = 6.5 → 6
Apr: H("A") = 1/2 = 0
May: H("M") = 13/2 = 6
June: H("J") = 10/2 = 5
July: H("J") = 10/2 = 5
Aug: H("A") = 1/2 = 0
Sep: H("S") = 19/2 = 9
Oct: H("O") = 15/2 = 7
Nov: H("N") = 14/2 = 7
Dec: H("D") = 4/2 = 2

方案一：线性探测法
让我们按顺序插入每个月份，遇到冲突时向后探测：

```
位置0: Apr -> Aug(+1)
位置1: Aug
位置2: Dec
位置3: Feb
位置4: -
位置5: Jan -> June(+1) -> July(+2)
位置6: Mar -> May(+1)
位置7: Oct -> Nov(+1)
位置8: Nov
位置9: Sep
位置10: -
位置11: -
位置12: -
位置13: -
位置14: -
位置15: -
位置16: -
```

计算平均查找长度：

成功查找：
- 1次比较：Apr, Dec, Feb, Jan, Mar, Oct, Sep (7个)
- 2次比较：Aug, June, May, Nov (4个)
- 3次比较：July (1个)

ASL成功 = (7×1 + 4×2 + 1×3)/12 = (7 + 8 + 3)/12 = 18/12 = 1.5次

不成功查找：需要检查到下一个空位置
- 位置4: 1次
- 位置10-16: 各1次
- 其他位置: 2-4次不等

ASL不成功 = (1 + 7×1 + 9×2)/17 ≈ 1.53次

方案二：链地址法
构造的哈希表如下（用箭头表示链接）：

```
位置0: Apr -> Aug
位置1: -
位置2: Dec
位置3: Feb
位置4: -
位置5: Jan -> June -> July
位置6: Mar -> May
位置7: Oct -> Nov
位置8: -
位置9: Sep
位置10-16: -
```

计算平均查找长度：

成功查找：
- 对于每个同义词链，查找长度为该位置上的结点序号
位置0: Apr(1), Aug(2)
位置2: Dec(1)
位置3: Feb(1)
位置5: Jan(1), June(2), July(3)
位置6: Mar(1), May(2)
位置7: Oct(1), Nov(2)
位置9: Sep(1)

ASL成功 = (6×1 + 4×2 + 1×3)/12 = (6 + 8 + 3)/12 = 17/12 ≈ 1.42次

不成功查找：
对每个空槽位，需要查找到链表末尾
- 空位置(1,4,8,10-16): 需1次比较
- 非空位置: 需要遍历到链表末尾

ASL不成功 = (10×1 + 2×2 + 3×3 + 2×2)/17 ≈ 1.47次

比较两种方法：
1. 链地址法的平均查找长度略优于线性探测法
2. 链地址法不会产生"聚集"现象，性能更稳定
3. 链地址法的空间利用更灵活，但需要额外的指针空间
4. 线性探测法实现更简单，但容易产生"聚集"

这个例子很好地展示了不同冲突处理方法的特点。在实际应用中，如果存储空间紧张且负载因子不高，可以考虑使用线性探测法；如果对查找性能要求较高且有足够的存储空间，链地址法可能是更好的选择。